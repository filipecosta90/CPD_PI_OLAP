\section{Experimentation}
\indent

Regarding the prior described lemas, we shall now assess wether if the linear algebra approach presents performance improvements when compared with the relational one. 
Before we discuss the measured performance results in the following section, we will briefly summarise characteristics of the multicore platform in our test suite, and present an overview of the performed tunings.\\

Throughout all the experiments, the same platform was used. The system, referenced as compute node 652-1, has two Intel\textsuperscript{\textregistered} Xeon\textsuperscript{\textregistered} E5-2670v2 (Ivy Bridge architecture) and features 64 GB of DDR3 RAM, supported at a frequency of 1333 MHz divided in 4 memory channels. Table \ref{table:characterization} fully characterises the hardware features of the test platform:

\begin{table}[H]
\centering
  \begin{tabular}{ | L{3.5cm} | R{5cm} | }
  
    \hline
    System & compute-652-1 \\ \hline \hline
        \# CPUs & 2\\ \hline
    CPU & Intel\textsuperscript{\textregistered} Xeon\textsuperscript{\textregistered} E5-2670v2\\ \hline 
    Architecture & Ivy Bridge \\ \hline 
    \# Cores per CPU & 10 \\ \hline 
    \# Threads per CPU & 20\\ \hline 
    Clock Freq. & 2.5 GHz\\ \hline \hline 
    L1 Cache & 320KB \newline 32KB per core\\ \hline 
    L2 Cache & 2560KB  \newline  256KB per core \newline\\ \hline 
    L3 Cache & 25600KB \newline shared \\ \hline \hline 
    Inst. Set Ext. & SSE4.2 \& AVX \\ \hline 
        \#Memory Channels & 4\\ \hline \hline

    Vendors Announced Peak Memory BW & 59.7 GB/s\\ \hline
    Measured\footnote{Stream Benchamrk} Peak Memory BW & 58.5GB/s\\ \hline
  \end{tabular}
     \caption{Architectural characteristics of the evaluation platform.}
     \label{table:characterization}
\end{table}

Regarding the software used for both relational and linear algebra, the corresponding versions are stated bellow:

\begin{itemize}
\item Linear Algebra: 
    \begin{itemize}
    \item Compiler: ICC version 16.0.0 (GCC version 4.4.6 compatibility)
    \begin{itemize}
        \item no vectorization: -O3 -std=c99 -no-vec -farray-notation 
        \item vectorization: -O3 -std=c99 -farray-notation -xAVX -vec-report7
    \end{itemize}
    \item Intel\textsuperscript{\textregistered} MKL Version	11.3
    \begin{itemize}
        \item Link line: -lmkl\_intel\_lp64 -lmkl\_core -lmkl\_sequential -lpthread -lm
    \end{itemize}
        \end{itemize}

\vspace{0.35cm}
    \item Relational Algebra (PostgreSQL version 9.6+);
    \begin{itemize}
        \item Built with the following dependencies:
        \begin{itemize}
            \item GCC version 4.9.0
            \item Python 2.6.6
        \end{itemize}
           \end{itemize}
\end{itemize}

Denote that PostgreSQL was compiled specifically for the test platform in order to fully take advantage of the available hardware. 

\subsection{Tuning the relational algebra engine}
Database, application, and storage servers ship with a large number of configuration parameters like buffer cache sizes, number of I/O daemons, and parameters input to the database query optimiser. Finding good settings for these parameters is a challenging task because of the complex ways in which parameter settings can affect performance. The parameters shared\_buffers, effective\_cache\_size, and work\_mem, were adjusted accordingly, with  shared\_buffers begin set to 2GB, effective\_cache\_size being set to 64GB, and work\_mem being set to 25MB. In order to further speed up RA queries, indexes were created for all the database tables.


\subsection{Tuning sparse CSC and CSR methods to assist data level parallelism}

Regarding SSE vectorisation several efforts were made in order to introduce it in both versions of the linear algebra approach. The usage of the performance Library Intel Math Kernel library fully assisted vectorisation on the method responsible for the dot product between sparse matrices and sparse matrix vector. The compiler was also instructed via auto vectorisation hints, and user mandated vectorisation, of the non existence of vector dependencies when that case was verified.\par 
Regarding the memory allocation alignment, all Data is aligned during creation accordingly to cache line size. Regarding the access alignment the compiler was instructed to to assume that all CSC and CSR arrays are aligned on an 32-byte boundary.

\subsection{Results from the tuning of  relational and linear algebra approaches}


We conducted experiments on the following TPC-H simplified query-1:



